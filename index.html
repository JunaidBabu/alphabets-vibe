<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alphabet & Number Tracing Fun!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @font-face {
        font-family: 'LucideIcons';
        src: url('https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf') format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        line-height: 1;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Basic styles for drawing */
      canvas {
        touch-action: none;
        cursor: crosshair;
        display: block;
      }
      .canvas-container {
          position: relative;
          width: 100%;
          max-width: 500px;
          margin: 0 auto;
          aspect-ratio: 1 / 1;
      }
      #drawingCanvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 5; /* Above hidden canvas */
      }
      /* Hidden canvas for accuracy check */
      #guideCanvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          visibility: hidden; /* Keep it in layout but not visible */
          z-index: 1;
      }
      #overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          overflow: hidden;
          z-index: 10;
      }
      .particle {
          position: absolute;
          width: 8px;
          height: 8px;
          background-color: #fbbf24;
          border-radius: 50%;
          pointer-events: none;
          opacity: 1;
          transform: translate(-50%, -50%);
          transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      }
      .reward-popup {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.5);
          color: #ec4899;
          font-size: 2.5rem;
          font-weight: bold;
          opacity: 0;
          pointer-events: none;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
          animation: reward-appear 0.8s ease-out forwards;
          z-index: 20;
      }
      @keyframes reward-appear {
          0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
          60% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
      }
      #iceCreamContainer {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 80px;
        height: 150px;
        z-index: 5;
      }
      .ice-cream-part {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        opacity: 0;
      }
      .ice-cream-part.visible {
        opacity: 1;
      }
      #cone {
        width: 0; height: 0;
        border-left: 30px solid transparent;
        border-right: 30px solid transparent;
        border-top: 60px solid #f59e0b;
        bottom: 0px; z-index: 1;
      }
      .scoop {
        width: 55px; height: 55px;
        border-radius: 50%; z-index: 2;
      }
      #scoop1 { background-color: #fff7d0; bottom: 45px; border: 1px solid #fef08a; }
      #scoop2 { background-color: #fda4af; bottom: 80px; border: 1px solid #f472b6; }
      #scoop3 { background-color: #a16207; bottom: 115px; border: 1px solid #854d0e; }
      #sprinkles {
        width: 50px; height: 20px;
        bottom: 145px; z-index: 3;
        background-image: radial-gradient(#34d399 15%, transparent 16%),
                          radial-gradient(#60a5fa 15%, transparent 16%),
                          radial-gradient(#fb7185 15%, transparent 16%);
        background-size: 10px 10px;
        background-position: 0 0, 5px 5px, 10px 0px;
        background-repeat: repeat;
      }
      #cherry {
        width: 15px; height: 15px;
        background-color: #dc2626; border-radius: 50%;
        bottom: 165px;
        border: 1px solid #b91c1c; z-index: 4;
      }
      #yummyText {
          position: absolute; top: 50%; left: 50%;
          transform: translate(-50%, -50%) scale(0);
          font-size: 2rem; color: #16a34a; font-weight: bold;
          opacity: 0; animation: yummy-appear 1.5s ease-out forwards;
          z-index: 30;
      }
      @keyframes yummy-appear {
          0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
      }
       .try-again-popup {
          position: absolute;
          top: 60%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.5);
          color: #f87171;
          font-size: 1.8rem;
          font-weight: bold;
          opacity: 0;
          pointer-events: none;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
          animation: try-again-appear 1s ease-out forwards;
          z-index: 20;
       }
       @keyframes try-again-appear {
          0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
       }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@700&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-to-br from-sky-200 via-blue-300 to-indigo-400 min-h-screen flex flex-col items-center justify-center p-4 font-['Baloo_2',_cursive] text-slate-800 overflow-hidden">

    <div class="bg-white/80 backdrop-blur-sm rounded-3xl shadow-2xl p-6 md:p-10 w-full max-w-3xl text-center relative">

        <div id="iceCreamContainer">
            <div id="cone" class="ice-cream-part"></div>
            <div id="scoop1" class="ice-cream-part scoop"></div>
            <div id="scoop2" class="ice-cream-part scoop"></div>
            <div id="scoop3" class="ice-cream-part scoop"></div>
            <div id="sprinkles" class="ice-cream-part"></div>
            <div id="cherry" class="ice-cream-part"></div>
        </div>

        <h1 class="text-3xl md:text-5xl font-bold mb-6 text-indigo-600">Let's Write!</h1>

        <div class="mb-4 flex items-center justify-center">
            <div class="canvas-container">
                <canvas id="drawingCanvas" class="bg-white rounded-2xl shadow-inner border-4 border-blue-300"></canvas>
                <canvas id="guideCanvas"></canvas>
                <div id="overlay"></div>
            </div>
        </div>

        <div class="flex justify-center items-center space-x-4 mt-6">
            <button id="prevBtn" class="lucide bg-orange-400 hover:bg-orange-500 text-white font-bold py-3 px-5 rounded-full shadow-lg transition duration-200 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" aria-label="Previous Character">
                &#xe4b2; </button>
            <button id="clearBtn" class="lucide bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-5 rounded-full shadow-lg transition duration-200 ease-in-out transform hover:scale-105" aria-label="Clear Drawing">
                &#xe51b; </button>
            <button id="nextBtn" class="lucide bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-5 rounded-full shadow-lg transition duration-200 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" aria-label="Next Character">
                &#xe4b4; </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const guideCanvas = document.getElementById('guideCanvas'); // Hidden canvas
        const guideCtx = guideCanvas.getContext('2d', { willReadFrequently: true }); // Optimize for frequent reads
        const overlay = document.getElementById('overlay');
        const canvasContainer = document.querySelector('.canvas-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const clearBtn = document.getElementById('clearBtn');

        // Ice cream elements
        const iceCreamParts = { cone: document.getElementById('cone'), scoop1: document.getElementById('scoop1'), scoop2: document.getElementById('scoop2'), scoop3: document.getElementById('scoop3'), sprinkles: document.getElementById('sprinkles'), cherry: document.getElementById('cherry') };
        const iceCreamOrder = ['cone', 'scoop1', 'scoop2', 'scoop3', 'sprinkles', 'cherry'];
        const MAX_ICE_CREAM_PROGRESS = iceCreamOrder.length;

        // --- Configuration ---
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split('');
        const rewardWords = ["Yes!", "Wow!", "Super!", "Yeah!", "Nice!", "Great!"];
        const rewardEmojis = ["ðŸ‘", "ðŸ‘", "ðŸŽ‰", "âœ¨"];
        let currentCharacterIndex = 0;
        let isDrawing = false;
        let userPathPoints = []; // Store user's drawing points {x, y}
        let startX = 0, startY = 0, lastX = 0, lastY = 0;
        const lineWidth = 12; // User line width
        const lineColor = '#333';
        const guideColorVisible = '#e5e7eb'; // Faint guide on visible canvas
        const guideColorHidden = [0, 0, 255, 255]; // RGBA for solid blue on hidden canvas
        // const guideLineWidthHidden = 25; // No longer needed for fillText
        const guideFontSizeRatio = 0.7;
        const minDrawDistance = 10; // Min distance for any stroke
        const accuracyThreshold = 0.85; // Require 85% accuracy (adjust as needed)
        const sampleRate = 5; // Check every 5th point for accuracy
        const checkRadius = 3; // Check a 7x7 pixel area (3 pixels around the point) on hidden canvas
        let iceCreamProgress = 0;

        // --- Canvas Setup ---
        function resizeCanvas() {
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;

            [canvas, guideCanvas].forEach(c => {
                c.width = containerWidth;
                c.height = containerHeight;
                c.style.width = `${containerWidth}px`;
                c.style.height = `${containerHeight}px`;
            });

            overlay.style.width = `${containerWidth}px`;
            overlay.style.height = `${containerHeight}px`;

            const fontStyle = `${canvas.height * guideFontSizeRatio}px 'Baloo 2', cursive`;
            ctx.font = fontStyle;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            guideCtx.font = fontStyle;
            guideCtx.textBaseline = 'middle';
            guideCtx.textAlign = 'center';

            drawGuideCharacter();
        }

        // --- Drawing Logic ---
        function startDrawing(e) {
            isDrawing = true;
            userPathPoints = [];
            [startX, startY] = getPointerPosition(e);
            [lastX, lastY] = [startX, startY];
            userPathPoints.push({ x: startX, y: startY });
        }

        function draw(e) {
            if (!isDrawing) return;
            const [currentX, currentY] = getPointerPosition(e);
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            userPathPoints.push({ x: currentX, y: currentY });
            createParticle(currentX, currentY);
            [lastX, lastY] = [currentX, currentY];
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const [endX, endY] = getPointerPosition(e);
            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            if (distance >= minDrawDistance && userPathPoints.length > 1) {
                checkAccuracy();
            }
            ctx.beginPath();
        }

        function getPointerPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX ?? e.touches?.[0]?.clientX;
            const clientY = e.clientY ?? e.touches?.[0]?.clientY;
            if (clientX === undefined || clientY === undefined) {
                 if (e.offsetX && e.offsetY) return [e.offsetX, e.offsetY];
                 return [lastX, lastY];
            }
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (clientX - rect.left) * scaleX;
            let y = (clientY - rect.top) * scaleY;
            x = Math.max(0, Math.min(canvas.width, x));
            y = Math.max(0, Math.min(canvas.height, y));
            return [x, y];
        }

        // --- Particle Effect ---
        function createParticle(x, y) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            particle.style.left = `${(x / canvas.width) * 100}%`;
            particle.style.top = `${(y / canvas.height) * 100}%`;
            overlay.appendChild(particle);
            setTimeout(() => {
                particle.style.opacity = '0';
                particle.style.transform = 'translate(-50%, -50%) scale(0)';
            }, 10);
            setTimeout(() => particle.remove(), 510);
        }

        // --- Character Logic ---
        function drawGuideCharacter() {
            const char = characters[currentCharacterIndex];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);

            // 1. Draw faint guide on visible canvas
            ctx.fillStyle = guideColorVisible;
            ctx.fillText(char, canvas.width / 2, canvas.height / 2);

            // 2. Draw SOLID FILLED guide on hidden canvas for checking
            //    <<< CHANGE IS HERE >>>
            guideCtx.fillStyle = `rgba(${guideColorHidden.join(',')})`; // Use the blue color
            guideCtx.fillText(char, guideCanvas.width / 2, guideCanvas.height / 2); // Use fillText
            //    <<< END OF CHANGE >>>
        }

        function updateCharacter() {
            userPathPoints = [];
            drawGuideCharacter();
            prevBtn.disabled = currentCharacterIndex === 0;
            nextBtn.disabled = currentCharacterIndex === characters.length - 1;
            overlay.innerHTML = '';
        }

        function clearCanvas() {
            userPathPoints = [];
            drawGuideCharacter();
            overlay.innerHTML = '';
        }

        // --- Accuracy Check ---
        function checkAccuracy() {
            let accuratePoints = 0;
            let sampledPoints = 0;
            if (userPathPoints.length < sampleRate) {
                showTryAgainMessage();
                return;
            }
            for (let i = 0; i < userPathPoints.length; i += sampleRate) {
                sampledPoints++;
                const point = userPathPoints[i];
                if (isPointNearGuide(point.x, point.y)) {
                    accuratePoints++;
                }
            }
            const accuracy = sampledPoints > 0 ? accuratePoints / sampledPoints : 0;
            if (accuracy >= accuracyThreshold) {
                showReward();
                advanceIceCream();
            } else {
                showTryAgainMessage();
            }
        }

        function isPointNearGuide(x, y) {
            const startX = Math.max(0, Math.floor(x) - checkRadius);
            const startY = Math.max(0, Math.floor(y) - checkRadius);
            const width = Math.min(guideCanvas.width - startX, checkRadius * 2 + 1);
            const height = Math.min(guideCanvas.height - startY, checkRadius * 2 + 1);
            if (width <= 0 || height <= 0) return false;
            try {
                const imageData = guideCtx.getImageData(startX, startY, width, height).data;
                for (let i = 0; i < imageData.length; i += 4) {
                    if (imageData[i] === guideColorHidden[0] &&
                        imageData[i + 1] === guideColorHidden[1] &&
                        imageData[i + 2] === guideColorHidden[2]) {
                        return true; // Found a match (point is near/inside the filled blue shape)
                    }
                }
            } catch (e) {
                console.error("Error reading guide canvas data:", e);
                return false;
            }
            return false;
        }

        // --- Reward Logic ---
        function showReward() {
            const word = rewardWords[Math.floor(Math.random() * rewardWords.length)];
            const emoji = rewardEmojis[Math.floor(Math.random() * rewardEmojis.length)];
            const rewardPopup = document.createElement('div');
            rewardPopup.classList.add('reward-popup');
            rewardPopup.textContent = `${word} ${emoji}`;
            overlay.appendChild(rewardPopup);
            setTimeout(() => rewardPopup.remove(), 800);
        }

        function showTryAgainMessage() {
            const tryAgainPopup = document.createElement('div');
            tryAgainPopup.classList.add('try-again-popup');
            tryAgainPopup.textContent = "Try Again!";
            overlay.appendChild(tryAgainPopup);
            setTimeout(() => tryAgainPopup.remove(), 1000);
        }

        // --- Ice Cream Logic ---
        function advanceIceCream() {
            if (iceCreamProgress < MAX_ICE_CREAM_PROGRESS) {
                iceCreamProgress++;
                updateIceCreamVisual(iceCreamProgress);
                if (iceCreamProgress === MAX_ICE_CREAM_PROGRESS) {
                    showYummyMessage();
                    setTimeout(() => {
                        iceCreamProgress = 0;
                        updateIceCreamVisual(0);
                    }, 2000);
                }
            }
        }

        function updateIceCreamVisual(progress) {
            iceCreamOrder.forEach((partId, index) => {
                if (iceCreamParts[partId]) {
                    if (index < progress) {
                        iceCreamParts[partId].classList.add('visible');
                    } else {
                        iceCreamParts[partId].classList.remove('visible');
                    }
                }
            });
        }

        function showYummyMessage() {
             const yummyPopup = document.createElement('div');
             yummyPopup.id = 'yummyText';
             yummyPopup.textContent = "Yummy!";
             overlay.appendChild(yummyPopup);
             setTimeout(() => yummyPopup.remove(), 1500);
        }

        // --- Event Listeners ---
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerleave', stopDrawing);
        clearBtn.addEventListener('click', clearCanvas);
        prevBtn.addEventListener('click', () => {
            if (currentCharacterIndex > 0) {
                currentCharacterIndex--;
                updateCharacter();
            }
        });
        nextBtn.addEventListener('click', () => {
            if (currentCharacterIndex < characters.length - 1) {
                currentCharacterIndex++;
                updateCharacter();
            }
        });

        // --- Initial setup ---
        window.addEventListener('resize', resizeCanvas);
        setTimeout(() => {
             resizeCanvas();
             updateCharacter();
             updateIceCreamVisual(iceCreamProgress);
        }, 0);

    </script>

</body>
</html>
